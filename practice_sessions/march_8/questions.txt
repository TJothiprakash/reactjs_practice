Part 1: Core Concepts (State, Props, Events)
Component Communication (Amazon)

Create a Parent and Child component. Let the Parent hold a counter in state.
When the Child button is clicked, increment the counter in the Parent.

Dynamic List Rendering (Google)

Build a TodoList component that accepts an array of todos as props and displays them.
Add a button to remove a todo item when clicked.

Input Handling (Meta)

Make a controlled LoginForm component with email & password.
Display the live input below the form fields.

Button Toggle (Microsoft)

Build a component with a button that toggles between â€œLoginâ€ and â€œLogoutâ€.
Show a message like "Welcome back, User" only when logged in.

Props Drilling (Adobe)

Pass a userâ€™s name from Grandparent to Child (3-level deep component tree).
No context allowed â€” use only props.

âš›ï¸ Part 2: Hooks & Lifecycle
useEffect for API Call (Netflix)

Create a UserList component that fetches users from https://jsonplaceholder.typicode.com/users
Use useEffect and display user names in a list.

Custom Hook (Airbnb)

Write a custom hook useWindowWidth that tracks window resize and returns the current width.
Use it in a component to display â€œMobile Viewâ€ if width < 768px.

useRef for Focus (Google)

Make an input form where clicking a â€œFocusâ€ button puts the cursor into the input.
Use useRef.

Timer with useEffect (Facebook)

Build a countdown timer from 60 seconds that updates every second.
Add a â€œResetâ€ button to restart the timer.

Dependency Array Debug (Amazon)

Build a component that increments a counter every time a prop changes, but do not use the prop in the dependency array.
Debug why it doesn't work correctly.

----------------------------------completed----------------------------april_08

ğŸš€ Part 3: Advanced Practice (Performance, Context, Optimization)
React.memo Demo (Microsoft)

Build a parent with two children â€” one child depends on state, the other doesnâ€™t.
Use React.memo to avoid unnecessary re-renders.

Context API (Netflix)

Build a simple theme toggler using React Context.
Clicking a button should switch between Dark and Light mode globally.

Form with Validation (Apple)

Create a form with email & password.
Add validation: email must be valid, password at least 6 characters.
Show error messages live.

useReducer for Complex State (Tesla)

Implement a cart system using useReducer.
Handle ADD_ITEM, REMOVE_ITEM, CLEAR_CART.

Lazy Loading (Meta)

Create a component that lazily loads another component on button click.
Show a loader while itâ€™s loading.

ğŸ§© Part 4: Debugging & Thinking Problems
Bug Fix Challenge

Given a list with keys not defined properly, identify and fix why React warns â€œEach child should have a unique keyâ€.

1. Infinite Re-render Debug
âŒ Problematic Code:
jsx
Copy
Edit
import { useEffect, useState } from "react";

function InfiniteLoop() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    setCount(count + 1); // ğŸš¨ Causes re-render every time
  }, [count]);

  return <div>Count: {count}</div>;
}
âš ï¸ Why Infinite Loop?
setCount updates count

count is in dependency array

useEffect runs again â†’ infinite loop

âœ… Fix:
Only run it once, or use proper conditionals:

jsx
Copy
Edit
useEffect(() => {
  // Only run once on mount
  setCount((prev) => prev + 1);
}, []);
2. Uncontrolled to Controlled Warning
âŒ Problem Code:
jsx
Copy
Edit
function UncontrolledInput() {
  const [name, setName] = useState();

  return (
    <input value={name} onChange={(e) => setName(e.target.value)} />
  );
}
âš ï¸ Why Warning?
On initial render, value is undefined â†’ uncontrolled

After typing, value becomes a string â†’ controlled

âœ… Fix:
Initialize with "" to keep it controlled from the start.

jsx
Copy
Edit
const [name, setName] = useState(""); // ğŸ‘ˆ Now it's always controlled
3. React Key Prop Drill (Wrong key usage)
âŒ Problem Code (index used as key):
jsx
Copy
Edit
function BadKeyList({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>
          {item}
        </li>
      ))}
    </ul>
  );
}
âš ï¸ What goes wrong?
Inserting/removing items in the list causes mismatch between keys and DOM nodes.

React reuses incorrect elements â†’ bad performance or weird bugs in inputs.

âœ… Correct Version:
Use a unique ID:

jsx
Copy
Edit
{items.map((item) => (
  <li key={item.id}>{item.name}</li>
))}
4. React StrictMode Behavior (Meta)
âœ… Component:
jsx
Copy
Edit
import React, { useEffect } from "react";

function MyComponent() {
  useEffect(() => {
    console.log("âœ… Mounted");

    return () => {
      console.log("âŒ Unmounted");
    };
  }, []);

  return <div>Hello, StrictMode!</div>;
}
ğŸ§ª App Component:
jsx
Copy
Edit
import React from "react";
import ReactDOM from "react-dom/client";
import MyComponent from "./MyComponent";

const root = ReactDOM.createRoot(document.getElementById("root"));

root.render(
  <React.StrictMode>
    <MyComponent />
  </React.StrictMode>
);
âš ï¸ What youâ€™ll see in the console:
Copy
Edit
âœ… Mounted
âŒ Unmounted
âœ… Mounted
ğŸ¤” Why double render?
React.StrictMode intentionally mounts/unmounts components twice in dev mode to:

Detect side effects

Ensure cleanup logic works properly

This only happens in development, not in production.